#! /usr/bin/env python3
# -*- coding: utf-8 -*-

#
# Karel Brinda (brinda@fjfi.cvut.cz)
#
# Department of Mathematics
# Faculty of Nuclear Sciences and Physical Engineering
# Czech Technical University in Prague
#

"""
.. module:: libwords
	:platform: Unix, Windows

.. module_author: Karel Brinda (brinda@fjfi.cvut.cz)
"""

#################
# CONFIGURATION #
#################
DEBUG = 0


#################
#	CLASSES   #
#################

import libmatrix
import os

class Word:
	"""
	Generic class for an infinity word.
	"""
	
	def __init__(self, prefix=(0,)):
		"""
		Set a prefix of the word and set empty alphabet

		:param prefix: Prefix which approximates the word represented by this class.
		:type prefix: Tuple.
		:raises: TypeError
		"""

		if not isinstance(prefix, tuple):
			raise TypeError("argument initialPrefix muset be a tuple")

		#TODO: add support for reaching all factors up to given length
		self.prefix = prefix
		self.alphabet = tuple(set(prefix))

	#TODO: complete the function
	def getComplexity(self, n, enoughPrefixLength=0):
		if not isinstance(n, int):
			raise TypeError("argument length must be an integer")

		if n > len(self.prefix) or n < 0:
			raise ValueError("n should be between 0 and length of the generated prefix")

		if not isinstance(enoughPrefixLength, int):
			raise TypeError("argument enoughPrefixLength must be an integer")
		elif enoughPrefixLength==0:
			enoughPrefixLength=len(self.prefix)
		elif enoughPrefixLength>len(self.prefix):
			raise ValueError("argument enoughPrefixLength must be greater as or equal to length of given prefix")

		factors=set()

		for i in range(enoughPrefixLength-n):
			factors.add(str(self.prefix[i:i+n]))
		return (len(factors),factors)

	# TODO: opravit
	# TODO: catch bad parameters (length > len(self.prefix))
	# TODO: dopsat testy na tuhle metodu
	# Prefix method
	def getAbelianComplexity(self, n, enoughPrefixLength=0):
		if not isinstance(n, int):
			raise TypeError("argument length must be an integer")

		if n > len(self.prefix) or n < 0:
			raise ValueError("n should be between 0 and length of the generated prefix")

		if not isinstance(enoughPrefixLength, int):
			raise TypeError("argument enoughPrefixLength must be an integer")
		elif enoughPrefixLength==0:
			enoughPrefixLength=len(self.prefix)
		elif enoughPrefixLength>len(self.prefix):
			raise ValueError("argument enoughPrefixLength must be greater as or equal to length of given prefix")

		parikhVectors=[]

		#first Parikh vector (at the position 0)
		currentParikhVector = {}
		tmp_prefix = self.prefix[0:n]
		for letter in self.alphabet:
			currentParikhVector[letter] = 0
		for letter in tmp_prefix:
			currentParikhVector[letter] += 1
		pV=list(currentParikhVector.values())
		#print(libmatrix.Matrix([pV]))
#		print("\n \n hash:" ,hash(libmatrix.Matrix([pV])))
		parikhVectors.append(libmatrix.Matrix([pV]))

		#following Parikh vectors
		for i in range(enoughPrefixLength-n):
			newPosition = i + n
			newPositionLetter = self.prefix[newPosition]
			oldPosition = i
			oldPositionLetter = self.prefix[oldPosition]
			currentParikhVector[oldPositionLetter] -= 1
			currentParikhVector[newPositionLetter] += 1
			pV=list(currentParikhVector.values())
			#print(libmatrix.Matrix([pV]))
			if libmatrix.Matrix([pV]) not in parikhVectors:
				parikhVectors.append(libmatrix.Matrix([pV]))
		#print (parikhVectors)
		return (len(parikhVectors),parikhVectors)
		
	def pomoc(self,line):
		ret = libmatrix.Matrix(
				[list( map(int, line.strip().split(" ") ) )]
			)
		#print ("ret ",ret)
		return ret


	def getAbelianComplexityC(self,n,enoughPrefixLength,program="AC.exe"):
		result = os.popen("" + program + " " + str(n) + " " + str(enoughPrefixLength), "r").read().strip()
		lines = result.splitlines()
		parVec = list(map(self.pomoc,lines))
		#print(parVec)
	
		return len(parVec), parVec 



##################################
##################################

class WordSubstitution (Word):
	"""
	Class for an infinity word generated by a substitution.
	"""
	
	def __init__(self, substitution, prefix=[0]):
		"""
		Set a substitution which will be used to generate prefixes,
		set an alphabet and a substitution matrix with a respect to the
		given substitution. 

		:param substitution: Substitution associated to the word represented by this class.
		:type substitution: Dictionary.
		:param prefix: Initial prefix which approximates the word represented by this class.
		:type prefix: Tuple.
		:raises: TypeError
		"""

		Word.__init__(self)

		self.setSubstitution(substitution)
		self.prefix = prefix
		self.factors={}
		self.prefixesModuloSkip=100  #0 .. no caching

	#TODO!!!!!!!
	def isSubstitutionPrimitive(self):
		"""
		Tell whether the given substitution is a primitive substitution.

		:returns: true or false
		"""
		pass


	def setSubstitution(self, substitution):
		"""
		Set new substitution to this word.

		:param substitution: New substitution associated to the word represented by this class.
		:type substitution: dictionary
		:raises: TypeError, ValueError
		"""

		if not isinstance(substitution, dict):
			raise TypeError("Substitution should be a dict")

		if substitution == {}:
			raise ValueError("Substitution should be non-empty")


		for letter in substitution:
			if not isinstance(letter, str) and not isinstance(letter, int):
				raise TypeError("Letters of the substitution must be strings or integers")
			if not isinstance(substitution[letter], tuple):
				raise TypeError("There should be tuples in the substitution")

		def __getAlphabetFromSubstitution(substitution):
			"""
			Return alphabet for the given substitution.

			:param substitution: Substitution.
			:type substitution: Dictionary.
			:returns: Alphabet of the given substitution.
			"""

			alphabet = set(substitution)
			for y in substitution.values():
				alphabet |= set(y)
			return tuple(alphabet)


		def __getMatrixFromSubstitution(substitution2):
			"""
			Return a matrix of the word's substitution.

			:param substitution2: Substitution.
			:type substitution2: Dictionary.
			:returns: Incidence matrix of the substitution.
			"""

			alphabet = list(__getAlphabetFromSubstitution(substitution2))
			substitutionMatrix = libmatrix.Matrix(m=len(alphabet), n=len(alphabet))

			i = 0
			lettersTable = {}
			for letter in self.alphabet:
				lettersTable[i] = letter
				i += 1

			for i in range(len(alphabet)):
				letterI = lettersTable[i]
				currentRule = self.substitution[letterI]
				for ii in range(len(alphabet)):
					letterII = lettersTable[ii]
					substitutionMatrix[i][ii] = currentRule.count(letterII)

			return substitutionMatrix

		#substitution
		self.substitution = substitution

		#alphabet
		self.alphabet = __getAlphabetFromSubstitution(substitution)

		#substitution matrix
		self.substitutionMatrix = __getMatrixFromSubstitution(substitution)
	

	def useSubstitution(self, word):
		"""
			Applies its substitution on word word.

			:param word: Word which is substitution applied on.
			:type word: TODO
			:returns: Obtained word.
		"""
		# debug
		if DEBUG:
			print("I apply the substitution on ", word)
		# end_debug

		newWord = []
		for letter in word:
			newWord.extend(self.substitution[letter])
		return newWord

	#TODO: opravit generovani prefixu (aby se negeneroval zbytecne dlouhy
	def generatePrefix(self, length=0):
		"""
		Generate a prefix of the given length.

		:param length: Desired lenght of word.
		:type length: Int.
		:raises: ValueError.
		"""
		
		if length > 0 and len(self.prefix) >= length:
#			# debug
#			if DEBUG:
#				print ("Debug: Generating prefix: cutting the current prefix")
#			# end_debug
#			self.prefix = self.prefix[0:length]

			##if longer, don't cut
			pass
			
		elif length > 0:
			# debug
			if DEBUG:
				print ("Debug: Extending prefix:\n\t\tsubstitution", self.substitution, "\n\t\tinitial word", self.prefix, "\n\t\tlength", length)
			# end_debug
			i = 0
			while len(self.prefix) < length:
				tmp_newPrefix = self.useSubstitution(self.prefix)
				tmp_newPrefix = tmp_newPrefix[0:length]
				self.prefix = tmp_newPrefix

				# debug
				if DEBUG:
					print ("Debug: #iteration", i, " => prefix ", tmp_newPrefix)
				# end_debug
				
				i += 1
			##if longer, don't cut
			#self.prefix = self.prefix[0:length]
			
		else:
			raise ValueError

	#TODO: complete the function
	def getFactorComplexity(self, n):
		raise NotImplementedError("not implemented, yet")

	#TODO: complete the function
	def getBalances(self,n,letters):
		raise NotImplementedError("not implemented, yet")

	#pomale
	def getFactors(self,n):
		"""
			Return ???

			:param n: For :math:`\\mathcal{L}_n`.
			:type n: Int.
			:returns: int -- return code (this is test)
			:raises: AttributeError, KeyError
		"""

		START_PREFIX = 10**5

		#nejvetsi delka nakesovanych faktoru mensich nebo rovno n
		m = max(
			filter(
				lambda x: x<=n,
				[0] +     list(self.factors.keys())
			)
		)
		#print ("m=",m)

		if m==n:
			return self.factors[n]

		factors=set()

		if m==0:
			if len(self.prefix)<START_PREFIX:
				self.generatePrefix(START_PREFIX)

			factors=set()

			for i in range(START_PREFIX-1):
				factors.add(tuple(self.prefix[i:i+2]))

			self.factors[2]=factors
			m=2

		for currentLength in range (m+1, n+1):
			print ("Haha, jsem u delky", currentLength)
			factors=set()
			for prefactor in self.factors[currentLength-1]:
				for i in range(2):
					prefactor = self.useSubstitution(prefactor)
				#print (prefactor)

				for ii in range(len(prefactor)-currentLength+1):
					factors.add(tuple(prefactor[ii:ii+currentLength]))
					#print("rezu",ii,"..",ii+currentLength-1,"z",len(prefactor))
			self.factors[currentLength]=factors

		return self.factors[n]

##################################
##################################

class WordBinaryNonPisot (WordSubstitution):
	"""
	Class for a Binary non-Pisot word. The substitution is:
            
	.. math::
		\\mathcal{A} = \\{0, 1\\}

		\\varphi:
            0 & \\rightarrow 01 \\\\
			1 & \\rightarrow  000
	"""

	def __init__(self):
		WordSubstitution.__init__(self, {
								  0:(0, 1),
								  1:(0, 0, 0)})

##################################
##################################

class WordChacon (WordSubstitution):
	"""
	Class for a Chacon word (variation number 1).

	.. math::
		\\mathcal{A} = \\{0, 1, 2\\}

		\\varphi:
			0 & \\rightarrow 0012 \\\\
			1 & \\rightarrow 12   \\\\
			2 & \\rightarrow 012
	"""

	def __init__(self):
		WordSubstitution.__init__(self, {
								  0:(0, 0, 1, 2),
								  1:(1, 2),
								  2:(0, 1, 2)})

##################################
##################################

class WordChacon2 (WordSubstitution):
	"""
	Class for a Chacon word (variation number 2).

	.. math::
		\\mathcal{A} = \\{0, 1\\}

	    \\varphi:
			0 & \\rightarrow 0^{q}1    \\\\
			1 & \\rightarrow 10^{q-1}1
	"""

	def __init__(self, q):
		WordSubstitution.__init__(self, {
								  0:(0,) * q + (1,),
								  1:(1,) + (0,) ^ (q-1) + (1,)})

##################################
##################################

class WordChacon3 (WordSubstitution):
	"""
	Class for a Chacon word (variation number 3).

	.. math::
		\\mathcal{A} = \\{0, 1, 2\\}

	    \\varphi:
			0 & \\rightarrow 01 \\\\
			1 & \\rightarrow 2^{r-1}012^{s-1} \\\\
			2 & \\rightarrow 2^r012^{s-1}
	"""

	#TODO: maybe WRONG

	def __init__(self, r, s):
		WordSubstitution.__init__(self, {
								  0:(0, 1),
								  1:(2,) * (r-1) + (0, 1) + (2,) * (s-1),
								  2:(2,) * r + (0, 1) + (2,) * (s-1)})

##################################
##################################

class WordChacon4 (WordSubstitution):
	"""
	Class for a Chacon word (non primitive).

	.. math::
		\\mathcal{A} = \\{0, 1\\}

	    \\varphi:
			0 & \\rightarrow 0010 \\\\
			1 & \\rightarrow 1
	"""

	def __init__(self):
		WordSubstitution.__init__(self, {
								  0:[0, 0, 1, 0],
								  1:[1]})

##################################
##################################

class WordDBonacci (WordSubstitution):
	"""
	Class for a d-bonacci word.

	.. math::
		\\mathcal{A} = \\{0, 1, 2, \\ldots, K-1\\}

	    \\varphi:
			0 & \\rightarrow 01 \\\\
			1 & \\rightarrow 02 \\\\
			  & \\vdots \\\\
			K-2 & \\rightarrow 0(K-1) \\\\
			K-1 & \\rightarrow 0
	"""

	def __init__(self, d):
		"""
		.. param K:: ..math..`K` for ..math..`K`-bonacci
		"""
		k = int(d)
		if k < 2:
			raise ValueError("K must be an integer greater as 1")

		substitution = {}
		for i in range(k):
			substitution[i] = (0, i + 1)
		substitution[k-1] = (0,)

		WordSubstitution.__init__(self, substitution)

##################################
##################################

class WordNonSimpleParry (WordSubstitution):
	"""
	Class for a Non-simple Parry word.

	A = {0, 1, ... , K-1}
	"""

	#TODO: correct!! + check vectors tm and tp
	#FIX!!!!!
	def __init__(self, t, m):
		substitution = {}

		for i in range(len(t)):
			substitution[i] = tuple([0] * t[i] + [i + 1])
			substitution[len(t)-1] = tuple([0] * t[len(t)-1] + [m])

		WordSubstitution.__init__(self, substitution)

##################################
##################################

class WordPeriodDoubling (WordSubstitution):
	"""
	Class for a Period-doubling word.

	.. math::
		\\mathcal{A} = \\{0, 1\\}

	    \\varphi:
			0 & \\rightarrow 01 \\\\
			1 & \\rightarrow 00
	"""

	def __init__(self):
		WordSubstitution.__init__(self, {
								  0:(0, 1),
								  1:(0, 0)})

##################################
##################################

class WordRudinShapiro (WordSubstitution):
	"""
	Class for a Rudin-Shapiro word.

	.. math::
		\\mathcal{A} = \\{0, 1, 2, 3\\}

	    \\varphi:
			0 & \\rightarrow 01 \\\\
			1 & \\rightarrow 02 \\\\
			2 & \\rightarrow 31 \\\\
			3 & \\rightarrow 32
	"""

	def __init__(self):
		WordSubstitution.__init__(self, {
								  0:[0, 1],
								  1:[0, 2],
								  2:[3, 1],
								  3:[3, 2]})

##################################
##################################

class WordSimpleParry (WordSubstitution):
	"""
	Class for a Simple Parry word.

	A = {0, 1, ... , K-1}

	TODO: Factor complexity of infinity words... - Klouda, Pelantova
	      Asymptotic behaviour of beta-integers - Balkova
	"""

	#TODO: check vectors tm and tp
	def __init__(self, t):
		substitution = {}
		m = len(t)

		for i in range(m):
			substitution[i] = tuple([0] * t[i] + [i + 1])
			substitution[m-1] = tuple([0] * t[m-1])

		WordSubstitution.__init__(self, substitution)

##################################
##################################

class WordThueMorse (WordSubstitution):
	"""
	Class for a Thue-Morse word (variation number 1).

	.. math::
		\\mathcal{A} = \\{0, 1\\}

	    \\varphi:
			0 & \\rightarrow 01 \\\\
			1 & \\rightarrow 10
	"""

	def __init__(self):
		WordSubstitution.__init__(self, {
								  0:(0, 1),
								  1:(1, 0)})

##################################
##################################

class WordThueMorse2 (WordSubstitution):
	"""
	Class for a Thue-Morse word (variation number 2).

	.. math::
		\\mathcal{A} = \\{0, 1, 2\\}

	    \\varphi:
			0 & \\rightarrow 12 \\\\
			1 & \\rightarrow 102 \\\\
			2 & \\rightarrow 0
	"""

	def __init__(self):
		WordSubstitution.__init__(self, {
								  0:[1, 2],
								  1:[1, 0, 2],
								  2:[0]})

##################################
##################################

class WordThueMorse3 (WordSubstitution):
	"""
	Class for a Thue-Morse word (variation number 3).


	.. math::
		\\mathcal{A} = \\{0, 1, 2, 3\\}

		\\varphi:
			0 & \\rightarrow 12 \\\\
			1 & \\rightarrow 13 \\\\
			2 & \\rightarrow 20 \\\\
			3 & \\rightarrow 21
	"""

	def __init__(self):
		WordSubstitution.__init__(self, {
								  0:[1, 2],
								  1:[1, 3],
								  2:[2, 0],
								  3:[2, 1]})

##################################
##################################

class WordGeneralizedThueMorse (WordSubstitution):
	"""
	Class for a generalized Thue-Morse word.

	"""

	def __init__(self,b,d):
		subst = dict(
				(i, tuple(map(lambda x: x % d,tuple( range(i,i+b)))))
				for i in range(0,d)
		)
		WordSubstitution.__init__(self, subst)
